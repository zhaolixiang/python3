使用诸如Lock、RLock、Semphore之类的锁原语时，必须多加小心，锁的错误使用很容易导致死锁或相互竞争。依赖锁的代码应该保证当出现异常时可以正常的释放锁。

典型代码如下：

```
try:
    lock.acquire()
    #关键部分
    ...
finally:
    lock.release()
```

另外，所有种类的锁还支持上下文管理协议（写起来更简洁）：

with语句自动获取锁，并且在控制流离开上下文时自动释放锁。

```
with lock:
    #关键部分
    ...
```

此外，编写代码时一般应该避免同时获取多个锁，例如下面就应该尽量避免：

这通知很统一导致应用程序神秘死锁，尽管与集中策略可以避免出现这种情况（如分层锁定），但是最好在编写代码时避免这种嵌套锁。

```
with lock_A:
    #关键部分
    ...
    with lock_B:
        #B的关键部分
        ...
```

尽管在Python中可以使用各种锁和同步原语的组合编写非常传统的多线程程序，但有一种首推的编程方式要优于其他所有编程方式：即将多线程程序组织为多个独立任务的集合，这些任务之间通过消息队列进行通信，例如下面要讲的queue模块。

