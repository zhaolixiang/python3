> 事件用于在线程之间通信。一个线程发送【事件】信号，一个或多个其他线程等待它。
>
> Event实例管理着一个内部标志，可以使用set\(\)方法将它置为True，或者使用clear\(\)方法将它重置为False。wait\(\)方法将阻塞，直到标志为True。

# 语法：

```
e=Event()
创建新的Event实例，并将内部标志设置为False。
```

# 常用方法：

```
e.is_set():只有当内部标志设为True时才返回True

e.set()：将内部标志设置为True。等待它变为True的所有线程都讲被唤醒。

e.clear()：将内部标志重置为False。

e.wait(timeout)：阻塞直到内部标志为True。如果调用时内部标志为True，此方法将立即返回。
否则，它将阻塞，直到另一个线程调用set()方法将标志设置为True，或者出现可选的超时时。
```

### 注意

> 尽管Event对象可用于给其他线程发送信号，但不应该使用他们来实现在生产者和消费者的通知，例如下面代码：

```
evt=Event()

def producer():
    while True:
        #生产项
        ...
        evt.signal()
def consumer():
    while True:
        #等待一个项
        evt.wait()
        #消费项
        ...
        #清除事件并再次等待
        evt.clear()
```

> 应该 尽量避免上面代码，因为这段代码不可靠，因为在evt.wait\(\) 与evt.clear\(\)操作之间，生产者可能生产了一个新项。但是，通过清楚事件，在生产者创建一个新项之前，消费者可能看不到这个新项。最好的情况是：程序将经过一段很短的停滞，对项的处理被莫名其妙的推迟。最坏的情况是，由于事件信号丢失，整个程序将会挂起。要解决这类问题，最好使用条件变量。



