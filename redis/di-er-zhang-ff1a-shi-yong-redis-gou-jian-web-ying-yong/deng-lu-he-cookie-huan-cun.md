### 登录和cookie缓存

每当我们登录互联网服务的时候，这些服务都会使用cookie来记录我们的身份。cookie由少量数据组成，网站会要求我们的浏览器存储这些数据，并在每次服务器请求发送时将这些数据传回给服务器。对于用来登录的cookie，有两种常见的方式可以将登录信息存储在cookie里面：

* 签名【signed】cookie
* 令牌【token】cookie

签名cookie通常会存储用户名，可能还有用户ID，用户最后一次登录成功的时间，以及网站觉得有用的其他任何信息。除了用户的相关信息之外，签名cookie还包含了一个签名，服务器可以使用这个签名来验证浏览器发送的消息是否未经改动（比如将cookie中的登录用户名改成另一个用户）。

令牌cookie会在cookie里面存储一串随机字节作为令牌，服务器可以根据令牌在数据库中查询令牌的拥有者。随着时间的推移，旧令牌会被新令牌去掉。

| cookie类型 | 优点 | 缺点 |
| :--- | :--- | :--- |
| 签名cookie | 验证cookie所需的一切信息都存储在cookie里面，cookie可以包含额外的信息，并且对这些信息进行签名也很容易。 | 正确的处理签名很难，很容易忘记对数据进行签名，或者忘记验证数据的签名，从而造成安全漏洞。 |
| 令牌cookie | 添加信息非常容易，cookie的体积非常小，因此移动终端和速度较慢的客户端可以更快地发送请求。 | 需要在服务中存储更多信息，如果使用的是关系数据库，那么载入和存储的cookie的代价可能会很高。 |

这次我们使用令牌cookie来引用关系数据库表中负责存储用户登录信息的条目【entry】。除了用户登录信息之外，我们还可以将用户的访问时长和已浏览商品的数量等信息存储到数据库里面，这样便于将来通过分析这些信息来学习如果更好得向用户推销商品。

一般来说，用户在决定购买某个或某些商品之前，通常都会先浏览多个不同商品，而记录用户浏览过的所有商品以及用户最后一次访问页面的时间等信息，通常会导致大量的数据库写入。从长远来看，用户的这些浏览数据的确非常有用，但问题是，即便经过优化，大多数关系数据库在每台数据库服务器上每秒也只能插入、更细或者删除200~2000个数据行。尽量批量插入、批量更新和批量删除等操作可以更快地速度执行，但因为客户端每次浏览网页都只更新少数几行，所以高速的批量插入在这里并不适用。

我们假设我们的网站每天的负载量都比较大：平均每秒大约1200次写入，高峰时期每秒接近6000次写入，所以它必须部署10台关系数据服务器才能应对高峰时期的负载量。而我们要做的就是适用Redis重新实现登录cookie功能，取代由关系数据库实现的登录cookie功能。

首先，我们将使用一个散列来存储登录cookie令牌和已登录用户之间的映射。要检查一个用户是否已经登录，需要根据给定的令牌来查找与之对应的用户，并在用户已经登录的情况下，返回该用户的ID。

```
def check_token(conn,token):
    #尝试获取并返回令牌对应的用户
    return conn.hget('login:',token)
```



