# 即时查询

说一个系统支持即时查询的意思就是无需预先定义系统接收的查询类型。关系型数据库有这个能力，它们会严格遵照指示执行任何完备的SQL查询，无论有什么条件。如果你进使用过关系型数据库，那么会认为即时查询是理所应当的。但是，并非所有的数据库都支持动态查询。举例来说，键值存储只能按一个维度来查询：键。和很多其他系统一样，键值存储牺牲了丰富的查询能力来换取一个简单的可伸缩模型。关系型数据库世界中，查询能力是最基础不过的事情，MongoDB的设计目标之一就是尽可能保留这种能力。

要了解MongoDB的查询语句如何工作，让我们先来看一个简单的例子，它设计文档和评论。假设想要找到所有带有politics标签、投票数大于10的文章，SQL查询大概会是这样的：

```
SELECT * FROM posts
    INNER JOIN posts_tags ON posts.id=posts_tags.post_id
    INNER JOIN tags ON posts_tags.tag_id==tags.id
    WHERE tags.text='politics' AND posts.vote_count>10;
```

MongoDB中的等效查询是用文档来做匹配的，特殊的【$gt】表示【大于】：

```
dp.posts.find({'tags':'politics','vote_count':{'$gt':10}});
```

请注意，这两个查询采用了不同的数据模型。SQL查询依赖于严格正规化的模型，其中文章和标签保存在不同的数据表中，而MongoDB的查询假定标签是存储在每个文章的文档中。两者都演示了对任意属性组合执行查询的能力，这是即时查询的本质。

正如之前提到的，一些数据库的查询模型过于简单，因此不支持即使查询。举例来说，你只能根据主键在键值存储中进行查询。对于查询而言，它并不知道这些键所对应的值。要根据第二属性进行查询，比如本例中的投票数，唯一的方法是自己写代码来构造条目，其中主键是指定的投票数，值是一个文档主键的列表，文档里包含了键中所指定的投票数。如果你在键值存储中使用了这种方法，那么一定会为此而深感愧疚，虽然这种做法在数据集较小时能管用，把多个索引塞进物理结构是单索引的存储中，这并不是一个好主意。而且，键值存储中基于散列的索引不支持范围查询，而在查询类似投票数这样的东西时，范围查询可能是必不可少地。

如果你之前是使用关系型数据库系统的，把即时查询作为常态，那么应该会发现MongoDB提供了类似的查询能力。如果正在评估多种不同的数据库技术，请牢记不是所有的数据库都支持即时查询，要是你的确需要这种能力，MongoDB会是一个不错的选择。但光是即时查询还是不够的，一旦数据集膨胀到一定程度，出于查询效率就必须使用索引。适当的索引能把查询和排序的速度提升一个数量级，所以支持即时查询的系统还应该要支持二级索引。

